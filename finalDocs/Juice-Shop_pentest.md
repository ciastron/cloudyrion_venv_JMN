# JUICE-SHOP PENTEST REPORT

This document provides a report of the vulnerabilities that we have found on Juice Shop WebApplication.


## SQL Injection

### Description

A SQL injection attack consists of the insertion or "injection" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database, recover the content of a given file present on the DBMS file system, and in some cases issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL commands are injected into data-plane input in order to affect the execution of predefined SQL commands. The login page is vulnerable to SQL injection attacks using that an attacker can log in to the application without knowing the credentials.

### Steps

- Checked for a login field to input user commands.
Tried to check for a security misconfiguration by adding a ' Symbol.

```
POST /rest/user/login HTTP/1.1
...

{
"email":"'",
"password":"1"
}
```

Responded with an SQLite error and also the SQL tables and password hash.

- Checked for a simple SQL injection by trying to bypass the authentication process with 

```
POST /rest/user/login HTTP/1.1
Accept: application/json, text/plain, */*

{
 "email":"'or 1=1 --",
 "password":"1"
}
```

### PoC

we check for security misconfiguration

![SQLINJ](img/SQL_Juice02.png)

we bypass the login authentication process and are able to login as admin.

![SQLINJ](img/SQL_Juice01.png)

### Mitigation

To prevent SQL Injection attacks you should implement input validation and parameterized queries, including prepared statements. The application code should never use the input directly. The developer must sanitize all input, not only web form inputs such as login forms. They must remove potential malicious code elements such as single quotes. It is also a good idea to turn off the visibility of database errors on your production sites. Database errors are used with SQL Injection to gain information about your database.

## Identification and Authentication Failures

### Description
Identification and authentication failures can occur when functions related to a user's identity, authentication, or session management are not implemented correctly or not adequately protected by an application. Attackers may be able to exploit identification and authentication failures by compromising passwords, keys, session tokens, or exploit other implementation flaws to assume other users' identities, either temporarily or permanently.

### Steps

By using the above SQL Injection to bypass the Authentication process we got access to the authentication token.

Next Step was to decode the Token and then to decrypt the password hash.

### PoC

Authentication Token
![IAF](img/IA_failures01.png)

Decoded Token
![IAF](img/IA_failures02.png)

Decrypted hash

![IAF](img/IA_failures03.png)

Login as admin with password 

![IAF](img/IA_failures04.png)

Succesfully logged in

![IAF](img/IA_failures05.png)

### Mitigation

- Where possible, implement multi-factor authentication to prevent automated credential stuffing, brute force, and stolen credential reuse attacks.
- Do not ship or deploy with any default credentials, particularly for admin users.
- Implement weak password checks, such as testing new or changed passwords against the top 10,000 worst passwords list.
- Align password length, complexity, and rotation policies with National Institute of Standards and Technology (NIST) 800-63b's guidelines in section 5.1.1 for Memorized Secrets or other modern, evidence-based password policies.
- Ensure registration, credential recovery, and API pathways are hardened against account enumeration attacks by using the same messages for all outcomes.
- Limit or increasingly delay failed login attempts, but be careful not to create a denial of service scenario. Log all failures and alert administrators when credential stuffing, brute force, or other attacks are detected.
- Use a server-side, secure, built-in session manager that generates a new random session ID with high entropy after login. Session identifier should not be in the URL, be securely stored, and invalidated after logout, idle, and absolute timeouts.


## CSRF in the update of the username

### Description
Cross-Site Request Forgery (CSRF) is an attack that forces authenticated users to submit a request to a Web application against which they are currently authenticated. CSRF attacks exploit the trust a Web application has in an authenticated user. 

### Steps 

An HTML page with this form will cause the user to automatically update his username

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="http://127.0.0.1:3000/profile" method="POST">
      <input type="hidden" name="username" value="CSRFIsSerious" />
    </form>
		<script>document.forms[0].submit()</script>
  </body>
</html>
```

### PoC
When the user clicks on the link that is responsible for sending the previous form, then the username is changed.
![csrf01](img/csrf01.png)

### Mitigation
Implement CSRF token with random value

## Reflected XSS (Cross Site Scripting)
### Description
A reflected XSS (also called a non-persistent XSS attack) is a specific type of XSS whose malicious script bounces off of another website to the victim's browser. It is passed in the query, typically, in the URL. It makes exploitation as easy as tricking a user to click on a link.
In this case, we can inject the malicious code into the search parameter of the URL. 

For example, the URL `http://127.0.0.1:3000/search?q=<img src=1 onerror="alert(1)"/>` will pop up an alert message. In other words, this allows an attacker to execute arbitrary JS on the victim's browser.
### Steps
### PoC

We use the search parameter in the URL to load an image. We add the error handler that is triggered if the image does not exist. The error handler contains JS that is executed because the image does not exist.

![XSS01](img/XSS01.png)

### Mitigation

For XSS attacks to be successful, an attacker needs to insert and execute malicious content on a webpage. Each variable in a web application needs to be protected. Ensuring that all variables go through validation and are then escaped or sanitized is known as perfect injection resistance. Any variable that does not go through this process is a potential weakness. Frameworks make it easy to ensure variables are correctly validated and escaped or sanitized.
